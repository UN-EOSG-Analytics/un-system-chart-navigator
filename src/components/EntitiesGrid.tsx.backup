"use client";

import {
  categoryOrderByPrincipalOrgan,
  getCategoryFootnote,
  getSortedCategories,
  getSortedSubcategories,
  normalizePrincipalOrgan,
  principalOrganConfigs,
  subcategoryOrderByPrincipalOrgan,
} from "@/lib/constants";
import { getAllEntities, searchEntities } from "@/lib/entities";
import { Entity } from "@/types/entity";
import { useRouter, useSearchParams } from "next/navigation";
import { forwardRef, useEffect, useImperativeHandle, useState } from "react";
import CategoryFootnote from "./CategoryFootnote";
import EntityCard from "./EntityCard";
import FilterControls from "./FilterControls";

const EntitiesGrid = forwardRef<{
  handleReset: () => void;
  toggleGroup: (groupKey: string) => void;
}>((props, ref) => {
  const entities = getAllEntities();
  const [searchQuery, setSearchQuery] = useState<string>("");
  const [activePrincipalOrgans, setActivePrincipalOrgans] = useState<
    Set<string>
  >(new Set(Object.keys(principalOrganConfigs)));
  const router = useRouter();
  const searchParams = useSearchParams();

  // Check for filter parameter on mount and when URL changes
  useEffect(() => {
    const filterParam = searchParams.get("filter");
    if (filterParam) {
      // Clear the filter parameter from URL after applying it
      router.replace("/", { scroll: false });
    }
  }, [searchParams, router]);

  const toggleGroup = (groupKey: string) => {
    // No-op: system grouping removed, keeping for backward compatibility
  };

  const togglePrincipalOrgan = (organKey: string) => {
    setActivePrincipalOrgans((prev) => {
      const allOrgans = Object.keys(principalOrganConfigs);
      const allActive = prev.size === allOrgans.length;

      // If all organs are active (no filter), start a new selection with just this organ
      if (allActive) {
        return new Set([organKey]);
      }

      // Otherwise, toggle the organ in the current selection
      const newOrgans = new Set(prev);

      if (newOrgans.has(organKey)) {
        // Remove the organ
        newOrgans.delete(organKey);
        // If no organs left, show all
        if (newOrgans.size === 0) {
          return new Set(allOrgans);
        }
      } else {
        // Add the organ
        newOrgans.add(organKey);
      }

      return newOrgans;
    });
  };

  const handleEntityClick = (entitySlug: string) => {
    // Update URL without navigation to prevent page jumping
    router.replace(`/?entity=${entitySlug}`, { scroll: false });
  };

  const handleReset = () => {
    // Full reset
    setSearchQuery("");
    setActivePrincipalOrgans(new Set(Object.keys(principalOrganConfigs)));
  };

  const handleFilterReset = () => {
    // Partial reset
    setSearchQuery("");
    setActivePrincipalOrgans(new Set(Object.keys(principalOrganConfigs)));
  };

  useImperativeHandle(ref, () => ({
    handleReset,
    toggleGroup,
  }));

  // Filter and sort entities
  const visibleEntities = (
    searchQuery.trim() ? searchEntities(searchQuery) : entities
  )
    .filter((entity: Entity) => {
      // Filter by principal organ - check if entity's organ is in active set
      const normalizedOrgan = normalizePrincipalOrgan(
        entity.un_principal_organ,
      );
      const organToCheck = Array.isArray(normalizedOrgan)
        ? normalizedOrgan[0] || "Other"
        : normalizedOrgan || "Other";
      if (!activePrincipalOrgans.has(organToCheck)) return false;

      return true;
    })
    .sort((a: Entity, b: Entity) => {
      // Sort by principal organ order, then alphabetically
      const aNormalized = normalizePrincipalOrgan(a.un_principal_organ);
      const bNormalized = normalizePrincipalOrgan(b.un_principal_organ);

      // Get primary organ for each entity (first one if array)
      const aOrgan = Array.isArray(aNormalized)
        ? aNormalized[0]
        : aNormalized;
      const bOrgan = Array.isArray(bNormalized)
        ? bNormalized[0]
        : bNormalized;

      if (aOrgan !== bOrgan) {
        const aConfig = principalOrganConfigs[aOrgan || ""];
        const bConfig = principalOrganConfigs[bOrgan || ""];
        const orderA = aConfig?.order ?? 999;
        const orderB = bConfig?.order ?? 999;
        return orderA - orderB;
      }

      // Within the same organ, sort alphabetically but put "Other" at the end
      const aIsOther = a.entity === "Other";
      const bIsOther = b.entity === "Other";
      if (aIsOther && !bIsOther) return 1;
      if (!aIsOther && bIsOther) return -1;
      return a.entity.localeCompare(b.entity);
    });

  // Group entities by principal organ
  const groupedEntities = visibleEntities.reduce(
    (acc: Record<string, Entity[]>, entity: Entity) => {
      const normalized = normalizePrincipalOrgan(entity.un_principal_organ);
      let groupKey: string;
      // Use first organ if array, or the organ itself, or "N/A" if null
      if (Array.isArray(normalized)) {
        groupKey = normalized[0] || "N/A";
      } else if (normalized === null || normalized === "") {
        groupKey = "N/A";
      } else {
        groupKey = normalized;
      }

      if (!acc[groupKey]) {
        acc[groupKey] = [];
      }
      acc[groupKey].push(entity);
      return acc;
    },
    {},
  );

  // Get sorted group keys by principal organ
  const sortedGroupKeys = (() => {
    // Include all principal organs, even those without entities
    const allOrgans = Object.keys(principalOrganConfigs);
    const organsWithEntities = Object.keys(groupedEntities);
    const allOrganKeys = Array.from(
      new Set([...allOrgans, ...organsWithEntities]),
    );

    return allOrganKeys.sort((a, b) => {
      const aConfig = principalOrganConfigs[a];
      const bConfig = principalOrganConfigs[b];
      const orderA = aConfig?.order ?? 999;
      const orderB = bConfig?.order ?? 999;
      return orderA - orderB;
    });
  })();

  return (
    <div className="w-full">
      {/* Search and Filter Controls */}
      <FilterControls
        activePrincipalOrgans={activePrincipalOrgans}
        onTogglePrincipalOrgan={togglePrincipalOrgan}
        entities={entities}
        searchQuery={searchQuery}
        onSearchChange={setSearchQuery}
        onReset={handleFilterReset}
        visibleEntitiesCount={visibleEntities.length}
      />

      {/* Entities Grid with Group Headings */}
      {visibleEntities.length === 0 ? (
        <div className="py-20 text-left">
          <p className="text-lg text-gray-500">
            No entities match the current filters.
          </p>
        </div>
      ) : (
        <div className="space-y-8">
          {sortedGroupKeys.map((groupKey) => {
            // Get the label for the principal organ
            const groupLabel =
              principalOrganConfigs[groupKey]?.label || groupKey;

            // Group entities by category
            const entitiesInGroup = groupedEntities[groupKey] || [];

            // Get principal organ colors
            const organConfig = principalOrganConfigs[groupKey];
            const organBgColor = organConfig?.bgColor || "bg-gray-300";
            const organTextColor = organConfig?.textColor || "text-black";

            // Group by category only if there are entities
            const categorizedEntities =
              entitiesInGroup.length > 0
                ? entitiesInGroup.reduce(
                    (acc: Record<string, Entity[]>, entity: Entity) => {
                      const category = entity.category || "N/A";
                      if (!acc[category]) {
                        acc[category] = [];
                      }
                      acc[category].push(entity);
                      return acc;
                    },
                    {},
                  )
                : {};

            const sortedCategories = getSortedCategories(
              Object.keys(categorizedEntities),
              groupKey, // Pass the principal organ as context
            );

            // Check if categories are defined in constants for this organ
            const hasDefinedCategories =
              categoryOrderByPrincipalOrgan[groupKey] !== undefined &&
              Object.keys(categoryOrderByPrincipalOrgan[groupKey]).length > 0;

            // Get the higher-level heading from config
            const sectionHeading = organConfig?.sectionHeading || null;

            // Convert Tailwind color class to CSS custom property
            const getCssColorVar = (bgColorClass: string): string => {
              const colorName = bgColorClass.replace("bg-", "");
              return `var(--color-${colorName})`;
            };

            // Get the dark variant of a color
            const getCssColorVarDark = (bgColorClass: string): string => {
              const colorName = bgColorClass.replace("bg-", "");
              return `var(--color-${colorName}-dark)`;
            };

            return (
                <div
                  key={groupKey}
                  className="animate-in fade-in slide-in-from-bottom-4"
                >
                  {/* Principal Organ Section with Background */}
                  <div
                    style={{
                      background: `linear-gradient(to bottom, color-mix(in srgb, ${getCssColorVar(organBgColor)} 15%, transparent), color-mix(in srgb, ${getCssColorVar(organBgColor)} 20%, transparent))`,
                    }}
                  >
                    {/* Principal Organ Heading with left border */}
                    <div
                      className="mb-6 border-l-[6px] pt-3 pl-4 sm:pt-5 sm:pl-4"
                      style={{
                        borderColor: getCssColorVarDark(organBgColor),
                      }}
                    >
                      <div className="mb-1 h-px bg-gradient-to-r from-gray-400 via-gray-200 to-transparent"></div>
                      <h2 className="text-xl font-semibold text-foreground uppercase sm:text-2xl">
                        {groupLabel}
                        {getCategoryFootnote(groupKey) && (
                          <CategoryFootnote
                            footnoteNumbers={getCategoryFootnote(groupKey)!}
                          />
                        )}
                      </h2>
                      {sectionHeading && (
                        <h3 className="mt-3 text-lg font-semibold text-gray-700 sm:text-xl">
                          {sectionHeading}
                        </h3>
                      )}
                    </div>

                    {/* Content with padding */}
                    <div className="px-6 pb-6 sm:px-8 sm:pb-8">
                      {/* If no entities, show nothing in content area */}
                      {entitiesInGroup.length === 0 ? null : (
                        <>
                          {/* If categories are not defined, show entities directly without category headers */}
                          {!hasDefinedCategories ? (
                            <div className="grid w-full grid-cols-3 gap-2 sm:grid-cols-4 sm:gap-3 md:grid-cols-6 lg:grid-cols-8 xl:grid-cols-10">
                              {entitiesInGroup.map((entity: Entity) => (
                                <EntityCard
                                  key={entity.entity}
                                  entity={entity}
                                  onEntityClick={handleEntityClick}
                                  customBgColor={organBgColor}
                                  customTextColor={organTextColor}
                                />
                              ))}
                            </div>
                          ) : (
                            // Categories within this Principal Organ
                            <div className="space-y-4">
                              {sortedCategories.map((category) => {
                                // Group entities by subcategory within this category
                                const subcategorizedEntities =
                                  categorizedEntities[category].reduce(
                                    (
                                      acc: Record<string, Entity[]>,
                                      entity: Entity,
                                    ) => {
                                      const subcategory =
                                        entity.subcategory || "";
                                      if (!acc[subcategory]) {
                                        acc[subcategory] = [];
                                      }
                                      acc[subcategory].push(entity);
                                      return acc;
                                    },
                                    {},
                                  );

                                // Check if subcategories are defined in constants for this organ
                                const hasDefinedSubcategories =
                                  subcategoryOrderByPrincipalOrgan[groupKey] !==
                                  undefined;

                                // Special rendering when subcategories are defined: show all defined subcategories with headers
                                if (hasDefinedSubcategories) {
                                  // Get all defined subcategories from constants
                                  const definedSubcategories = Object.keys(
                                    subcategoryOrderByPrincipalOrgan[
                                      groupKey
                                    ] || {},
                                  ).filter((key) => key !== ""); // Exclude empty string placeholder

                                  // Use all defined subcategories, not just ones with entities
                                  const allSubcategories = Array.from(
                                    new Set([...definedSubcategories]),
                                  );
                                  const sortedAllSubcategories =
                                    getSortedSubcategories(
                                      allSubcategories,
                                      groupKey,
                                    );

                                  // For Security Council, skip category header
                                  if (groupKey === "Security Council (SC)") {
                                    return (
                                      <div key={category} className="space-y-3">
                                        {sortedAllSubcategories.map(
                                          (subcategory) => {
                                            const entitiesInSubcategory =
                                              subcategorizedEntities[
                                                subcategory
                                              ] || [];

                                            return (
                                              <div key={subcategory || "none"}>
                                                {subcategory && (
                                                  <h3 className="subcategory-header mb-1.5 text-sm font-normal text-gray-500 sm:text-base">
                                                    {subcategory}
                                                  </h3>
                                                )}
                                                {entitiesInSubcategory.length >
                                                  0 && (
                                                  <div className="grid w-full grid-cols-3 gap-2 sm:grid-cols-4 sm:gap-3 md:grid-cols-6 lg:grid-cols-8 xl:grid-cols-10">
                                                    {entitiesInSubcategory.map(
                                                      (entity: Entity) => (
                                                        <EntityCard
                                                          key={entity.entity}
                                                          entity={entity}
                                                          onEntityClick={
                                                            handleEntityClick
                                                          }
                                                          customBgColor={
                                                            organBgColor
                                                          }
                                                          customTextColor={
                                                            organTextColor
                                                          }
                                                        />
                                                      ),
                                                    )}
                                                  </div>
                                                )}
                                              </div>
                                            );
                                          },
                                        )}
                                      </div>
                                    );
                                  }

                                  // For other organs with defined subcategories, show category header then subcategories
                                  return (
                                    <div key={category}>
                                      {/* Category H2 Header */}
                                      <h2 className="category-header mb-2 text-base font-medium text-gray-600 sm:text-lg">
                                        {category}
                                        {getCategoryFootnote(
                                          groupKey,
                                          category,
                                        ) && (
                                          <CategoryFootnote
                                            footnoteNumbers={
                                              getCategoryFootnote(
                                                groupKey,
                                                category,
                                              )!
                                            }
                                          />
                                        )}
                                      </h2>

                                      {/* All defined subcategories */}
                                      <div className="space-y-3">
                                        {sortedAllSubcategories.map(
                                          (subcategory) => {
                                            const entitiesInSubcategory =
                                              subcategorizedEntities[
                                                subcategory
                                              ] || [];

                                            return (
                                              <div key={subcategory || "none"}>
                                                {subcategory && (
                                                  <h3 className="subcategory-header mb-1.5 text-sm font-normal text-gray-500 sm:text-base">
                                                    {subcategory}
                                                  </h3>
                                                )}
                                                {entitiesInSubcategory.length >
                                                  0 && (
                                                  <div className="grid w-full grid-cols-3 gap-2 sm:grid-cols-4 sm:gap-3 md:grid-cols-6 lg:grid-cols-8 xl:grid-cols-10">
                                                    {entitiesInSubcategory.map(
                                                      (entity: Entity) => (
                                                        <EntityCard
                                                          key={entity.entity}
                                                          entity={entity}
                                                          onEntityClick={
                                                            handleEntityClick
                                                          }
                                                          customBgColor={
                                                            organBgColor
                                                          }
                                                          customTextColor={
                                                            organTextColor
                                                          }
                                                        />
                                                      ),
                                                    )}
                                                  </div>
                                                )}
                                              </div>
                                            );
                                          },
                                        )}
                                      </div>
                                    </div>
                                  );
                                } else {
                                  // Standard rendering for organs without defined subcategories
                                  return (
                                    <div key={category}>
                                      {/* Category H2 Header */}
                                      <h2 className="category-header mb-2 text-base font-medium text-gray-600 sm:text-lg">
                                        {category}
                                        {getCategoryFootnote(
                                          groupKey,
                                          category,
                                        ) && (
                                          <CategoryFootnote
                                            footnoteNumbers={
                                              getCategoryFootnote(
                                                groupKey,
                                                category,
                                              )!
                                            }
                                          />
                                        )}
                                      </h2>
                                      {/* Direct grid only - no subcategories shown */}
                                      <div className="grid w-full grid-cols-3 gap-2 sm:grid-cols-4 sm:gap-3 md:grid-cols-6 lg:grid-cols-8 xl:grid-cols-10">
                                        {categorizedEntities[category].map(
                                          (entity: Entity) => (
                                            <EntityCard
                                              key={entity.entity}
                                              entity={entity}
                                              onEntityClick={
                                                handleEntityClick
                                              }
                                              customBgColor={organBgColor}
                                              customTextColor={organTextColor}
                                            />
                                          ),
                                        )}
                                      </div>
                                    </div>
                                  );
                                }
                              })}
                            </div>
                          )}
                        </>
                      )}
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      )}
    </div>
  );
});

EntitiesGrid.displayName = "EntitiesGrid";

export default EntitiesGrid;
